<?php

/**
 * Phigrate
 *
 * PHP Version 5.3
 *
 * @category   Phigrate
 * @package    Task
 * @subpackage Db
 * @author     Manuel HERVO <manuel.hervo % gmail .com>
 * @copyright  2007 Cody Caughlan (codycaughlan % gmail . com)
 * @license    GPLv2 http://www.gnu.org/licenses/gpl-2.0.html
 * @link       https://github.com/Azema/Phigrate
 */

/**
 * @see Task_Base
 */
require_once 'Task/Db/AMigration.php';

/**
 * This is the primary work-horse method, it runs all migrations available,
 * up to the current version.
 *
 * @category   Phigrate
 * @package    Task
 * @subpackage Db
 * @author     Manuel HERVO <manuel.hervo % gmail .com>
 * @copyright  2007 Cody Caughlan (codycaughlan % gmail . com)
 * @license    GPLv2 http://www.gnu.org/licenses/gpl-2.0.html
 * @link       https://github.com/Azema/Phigrate
 */
class Task_Db_Export extends Task_Db_AMigration
{
    /**
     * Task name
     *
     * @var string
     */
    protected $_task = 'export';

    /**
     * Prefix the text of export
     *
     * @var string
     */
    protected $_prefixText = '--';

    /**
     * Primary task entry point
     *
     * @param array $args Arguments of task
     *
     * @return void
     */
    public function execute($args)
    {
        $this->_logger->debug(__METHOD__ . ' Start');
        if (! $this->_adapter->supportsMigrations()) {
            $msg = 'This database does not support migrations.';
            $this->_logger->warn($msg);
            require_once 'Phigrate/Exception/Task.php';
            throw new Phigrate_Exception_Task($msg);
        }
        $this->_adapter->setExport(true);
        $this->_return = "--\n--\tExport SQL by Phigrate\n--\n\n"
            . '-- Started: ' . date('Y-m-d g:ia T') . PHP_EOL . PHP_EOL
            . '-- [db:export]:' . PHP_EOL;
        try {
            $this->_execute($args);
        } catch(\Exception $e) {
            $this->_adapter->setExport(false);
            throw $e;
        }
        $this->_adapter->setExport(false);

        $this->_return .= "\n\n-- Finished: " . date('Y-m-d g:ia T') . "\n\n";
        // If output export
        if (array_key_exists('-o', $args)) {
            // Filepath
            $file = $args['-o'];
            // Si le chemin indiquÃ© est relatif
            if (substr($file, 0, 1) != '/') {
                // On rajoute le chemin courant au nom du fichier
                $file = getcwd() . '/' . $file;
            }
            $writable = true;
            // If file does not exists
            if (!file_exists($file)) {
                // Get directory parent
                $parent = dirname($file);
                // If directory parent is not writable
                if (!is_writable($parent)) {
                    $writable = false;
                }
            } elseif (!is_writable($file)) {
                // If file is not writable
                $writable = false;
            }
            // If file is writable
            if ($writable) {
                // Write content in file
                file_put_contents($file, $this->_return);
                $this->_return = 'The content is writed in file: ' . $file . "\n";
            } else {
                // Return the content and indicate the file is not writable
                $this->_return .= "\n\033[40m\033[1;31mThe file {$file} is not writable or his directory.\033[0m\n\n";
            }
        }
        $this->_logger->debug(__METHOD__ . ' End');
        return $this->_return;
    }

    /**
     * Return the usage of the task
     *
     * @return string
     */
    public function help()
    {
        $this->_logger->debug(__METHOD__ . ' Start');
        $output =<<<USAGE
Task: \033[36mdb:export\033[0m [\033[33mVERSION\033[0m]

The main purpose of the framework is to initiate the migration,
but you can also export the SQL generated by migration.

\t\033[33mVERSION\033[0m can be specified to go up (or down) to a specific
\tversion, based on the current version. If not specified,
\tall migrations greater than the current database version
\twill be executed.

\t\033[37mExample A:\033[0m The database is fresh and empty, assuming there
\tare 5 actual migrations, but only the first two should be run.

\t\t\033[35mphigrate db:export VERSION=20101006114707\033[0m

\t\033[37mExample B:\033[0m The current version of the DB is 20101006114707
\tand we want to go down to 20100921114643

\t\t\033[35mphigrate db:export VERSION=20100921114643\033[0m

\t\033[37mExample C:\033[0m You can also use relative number of revisions
\t(positive export up, negative export down).

\t\t\033[35mphigrate db:export VERSION=-2\033[0m

USAGE;
        $this->_logger->debug(__METHOD__ . ' End');
        return $output;
    }

    /**
     * run migrations
     *
     * @param array                   $migrations   The table of migration files
     * @param Phigrate_BaseMigration $targetMethod The migration class
     *
     * @return void
     */
    protected function _runMigrations($migrations, $targetMethod)
    {
        $this->_logger->debug(__METHOD__ . ' Start');
        $lastVersion = -1;
        $this->_return .= $this->_adapter->startTransaction() . "\n\n";
        foreach ($migrations as $file) {
            $fullPath = $this->_migrationDir . '/' . $file['file'];
            $this->_logger->debug('file: ' . var_export($file, true));
            if (! is_file($fullPath) || ! is_readable($fullPath)) {
                continue;
            }
            $this->_logger->debug('include file: ' . $file['file']);
            include_once $fullPath;
            require_once 'Phigrate/Util/Naming.php';
            $class = Phigrate_Util_Naming::classFromMigrationFile($file['file']);
            /** @param Phigrate_Migration_Base $obj */
            $obj = new $class($this->_adapter);
            $refl = new ReflectionObject($obj);
            if (! $refl->hasMethod($targetMethod)) {
                $msg = $class . ' does not have (' . $targetMethod
                    . ') method defined!';
                $this->_logger->warn($msg);
                require_once 'Phigrate/Exception/MissingMigrationMethod.php';
                throw new Phigrate_Exception_MissingMigrationMethod($msg);
            }
            $start = microtime(true);
            try {
                $obj->$targetMethod();
                //successfully ran migration, update our version and commit
                $this->_migratorUtil
                    ->resolveCurrentVersion($file['version'], $targetMethod);

            } catch (\Exception $e) {
                //wrap the caught exception in our own
                $msg = $file['class'] . ' - ' . $e->getMessage();
                $this->_logger->err($msg);
                throw new Phigrate_Exception($msg, $e->getCode(), $e);
            }
            $end = microtime(true);
            $diff = $this->_diffTimer($start, $end);
            $this->_return .= sprintf(
                "-- ========= %s ======== (%.2f)\n",
                $file['class'],
                $diff
            );
            $this->_return .= $this->_adapter->getSql();
            $this->_adapter->initSql();
            $lastVersion = $file['version'];
            $this->_logger->info('last_version: ' . $lastVersion);
        }//foreach
        $this->_return .= $this->_adapter->commitTransaction();
        //update the schema info
        $this->_logger->debug(__METHOD__ . ' End');
        return array('last_version' => $lastVersion);
    }
}

/* vim: set expandtab tabstop=4 shiftwidth=4: */
